#include <iostream>
#include <fstream>
#include <random>
#include <vector>
#include <algorithm>
#include <numeric>
#include <chrono>
#include <cmath>
#include <iomanip>
#include "GPStruct.h"
#include <sstream>
#include <string>

class Dataset {
  public:
    std::vector<std::vector<double>> data;
    // 0: boolean, 1: float
    std::vector<std::pair<std::string, int>> columnTypes;
};


// Hyperparameter ranges
struct HyperparameterRanges {
    // Normal GP
    int maxGenerationsMin, maxGenerationsMax;
    int populationSizeMin, populationSizeMax;
    int maxDepthMin, maxDepthMax;
    double crossoverRateMin, crossoverRateMax;
    double mutationRateMin, mutationRateMax;
    int tournamentSizeMin, tournamentSizeMax;
    // structured GP specific
    int globalThresholdMin, globalThresholdMax;
    int localThresholdMin, localThresholdMax;
    int cutoffDepthMin, cutoffDepthMax;
};

// Hyperparameter configuration
struct Configuration {
    int maxGenerations;
    int populationSize;
    int maxDepth;
    double crossoverRate;
    double mutationRate;
    int tournamentSize;
    // structured GP specific
    int globalThreshold;
    int localThreshold;
    int cutoffDepth;

    std::vector<double> fitnesses;
    double avgFitness;
    double stdDevFitness;
    // Combined score: higher avg fitness and lower std dev are better
    double score;
};

// Random number generation
std::random_device rd;
std::mt19937 gen(rd());

// Function to generate a random integer within a range
int randomInt(int min, int max) {
    std::uniform_int_distribution<> dis(min, max);
    return dis(gen);
}

// Function to generate a random double within a range
double randomDouble(double min, double max) {
    std::uniform_real_distribution<> dis(min, max);
    return dis(gen);
}

// Function to calculate standard deviation
double calculateStdDev(const std::vector<double>& values, double mean) {
    double variance = 0.0;
    for (const auto& val : values) {
        variance += std::pow(val - mean, 2);
    }
    return std::sqrt(variance / values.size());
}

// Function to calculate the combined score
// We want to maximize average fitness and minimize standard deviation
double calculateScore(double avgFitness, double stdDev) {
    // Higher weight on average fitness (0.7) and lower weight on std deviation (0.3)
    // We negate the std deviation because we want to minimize it
    return (0.7 * avgFitness) - (0.3 * stdDev);
}

// Function to print a configuration
void printConfiguration(const Configuration& config) {
    std::cout << "Configuration:" << std::endl;
    std::cout << "Max Generations: " << config.maxGenerations << std::endl;
    std::cout << "Population Size: " << config.populationSize << std::endl;
    std::cout << "Max Depth: " << config.maxDepth << std::endl;
    std::cout << "Crossover Rate: " << config.crossoverRate << std::endl;
    std::cout << "Mutation Rate: " << config.mutationRate << std::endl;
    std::cout << "Tournament Size: " << config.tournamentSize << std::endl;
    std::cout << "[STRUCT] Global Threshold: " << config.globalThreshold << std::endl;
    std::cout << "[STRUCT] Local Threshold: " << config.localThreshold << std::endl;
    std::cout << "[STRUCT] Cutoff Depth: " << config.cutoffDepth << std::endl;
    std::cout << "Average Fitness: " << config.avgFitness << std::endl;
    std::cout << "StdDev Fitness: " << config.stdDevFitness << std::endl;
    std::cout << "Score: " << config.score << std::endl;
}

// Function to save configurations to CSV
void saveConfigurationsToCSV(const std::vector<Configuration>& configurations, const std::string& filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file for writing: " << filename << std::endl;
        return;
    }
    
    // Write header
    file << "MaxGenerations,PopulationSize,MaxDepth,CrossoverRate,MutationRate,TournamentSize,globalThreshold,LocalThreshold,CutoffDepth,AvgFitness,StdDevFitness,Score\n";
    
    // Write data
    for (const auto& config : configurations) {
        file << config.maxGenerations << ","
             << config.populationSize << ","
             << config.maxDepth << ","
             << config.crossoverRate << ","
             << config.mutationRate << ","
             << config.tournamentSize << ","
             << config.globalThreshold << ","
             << config.localThreshold << ","
             << config.cutoffDepth << ","
             << config.avgFitness << ","
             << config.stdDevFitness << ","
             << config.score << "\n";
    }
    
    file.close();
}

// Function to load dataset
Dataset* fetchDataset(const std::string& datasetName) {
    // This is the same function as in your original code
    if (datasetName.empty()) {
        std::cerr << "No dataset name provided" << std::endl;
        return nullptr;
    }

    std::ifstream file(datasetName);
    try {
        if (!file.is_open()) {
            std::cerr << "Failed to open dataset: " << datasetName << std::endl;
            return nullptr;
        }
    } catch (const std::exception& e) {
        std::cerr << "Error opening file: " << e.what() << std::endl;
        return nullptr;
    }

    std::string line;

    std::getline(file, line);
    std::vector<std::pair<std::string, int>> columnTypes;
    std::stringstream ss(line);
    std::string token;

    std::vector<std::string> booleanColumns = {"sex", "antivirals", "fatigue", "malaise", "anorexia", "histology"};

    while (std::getline(ss, token, '\t')) {
        token.erase(0, token.find_first_not_of(" \t"));
        token.erase(token.find_last_not_of(" \t") + 1);
        if (token.empty() || token == "target") continue;

        // Check if token is a boolean column
        int type = (std::find(booleanColumns.begin(), booleanColumns.end(), token) != booleanColumns.end()) ? 0 : 1;
        columnTypes.push_back({token, type});
    }

    std::vector<std::vector<double>> fullDataset;

    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string token;
        std::vector<double> rowData;

        while (std::getline(ss, token, '\t')) {
            try {
                rowData.push_back(std::stod(token));
            } catch (const std::invalid_argument&) {
                rowData.push_back(0.0);  // In case of an invalid number, default to 0
            }
        }

        fullDataset.push_back(rowData);
    }
    file.close();
    
    Dataset* ds = new Dataset();
    ds->data = fullDataset;
    ds->columnTypes = columnTypes;

    return ds;
}

// Main hyperparameter tuning function
void tuneHyperparameters(bool useStructuredGP = true) {
    std::cout << "Starting hyperparameter tuning for " 
              << (useStructuredGP ? "Structure-based GP" : "Normal GP") << std::endl;
    
    // Define hyperparameter ranges
    HyperparameterRanges ranges;
    ranges.maxGenerationsMin = 50;
    ranges.maxGenerationsMax = 200;
    ranges.populationSizeMin = 50;
    ranges.populationSizeMax = 200;
    ranges.maxDepthMin = 3;
    ranges.maxDepthMax = 8;
    ranges.crossoverRateMin = 0.5;
    ranges.crossoverRateMax = 0.9;
    ranges.mutationRateMin = 0.05;
    ranges.mutationRateMax = 0.3;
    ranges.tournamentSizeMin = 2;
    ranges.tournamentSizeMax = 7;
    // structured GP specific
    ranges.globalThresholdMin = 1;
    ranges.globalThresholdMax = 5;
    ranges.localThresholdMin = 1;
    ranges.localThresholdMax = 5;
    ranges.cutoffDepthMin = 2;
    ranges.cutoffDepthMax = 6;
    
    // Load dataset
    Dataset* dataset = fetchDataset("preprocessing/hepatitis_cleaned.tsv");
    if (!dataset) {
        std::cerr << "Failed to load dataset" << std::endl;
        return;
    }
    
    // Number of configurations to try
    const int numConfigurations = 25;
    
    // Number of runs for each configuration to assess stability
    const int numRuns = 10;
    
    // Store configurations
    std::vector<Configuration> configurations;
    
    // Try different configurations
    for (int configIdx = 0; configIdx < numConfigurations; configIdx++) {
        // Generate random configuration
        Configuration config;
        config.maxGenerations = randomInt(ranges.maxGenerationsMin, ranges.maxGenerationsMax);
        config.populationSize = randomInt(ranges.populationSizeMin, ranges.populationSizeMax);
        config.maxDepth = randomInt(ranges.maxDepthMin, ranges.maxDepthMax);
        config.crossoverRate = randomDouble(ranges.crossoverRateMin, ranges.crossoverRateMax);
        config.mutationRate = randomDouble(ranges.mutationRateMin, ranges.mutationRateMax);
        config.tournamentSize = randomInt(ranges.tournamentSizeMin, ranges.tournamentSizeMax);
        // structured GP specific
        config.globalThreshold = randomInt(ranges.globalThresholdMin, ranges.globalThresholdMax);
        config.localThreshold = randomInt(ranges.localThresholdMin, ranges.localThresholdMax);
        config.cutoffDepth = randomInt(ranges.cutoffDepthMin, ranges.cutoffDepthMax);
        
        // Ensure crossover + mutation rates don't exceed 1.0
        if (config.crossoverRate + config.mutationRate > 1.0) {
            double totalRate = config.crossoverRate + config.mutationRate;
            config.crossoverRate = config.crossoverRate / totalRate * 0.95;
            config.mutationRate = config.mutationRate / totalRate * 0.95;
        }
        
        std::vector<double> applicationRates = {config.crossoverRate, config.mutationRate};
        
        std::cout << "Testing configuration " << configIdx + 1 << " of " << numConfigurations << std::endl;
        std::cout << "-------------------------" << std::endl;
        std::cout << "Max Generations: " << config.maxGenerations << std::endl;
        std::cout << "Population Size: " << config.populationSize << std::endl;
        std::cout << "Max Depth: " << config.maxDepth << std::endl;
        std::cout << "Crossover Rate: " << config.crossoverRate << std::endl;
        std::cout << "Mutation Rate: " << config.mutationRate << std::endl;
        std::cout << "Tournament Size: " << config.tournamentSize << std::endl;
        std::cout << "[STRUCT] Global Threshold: " << config.globalThreshold << std::endl;
        std::cout << "[STRUCT] Local Threshold: " << config.localThreshold << std::endl;
        std::cout << "[STRUCT] Cutoff Depth: " << config.cutoffDepth << std::endl;
        std::cout << "-------------------------" << std::endl;
        
        // Run multiple times to assess stability
        config.fitnesses.resize(numRuns);
        
        for (int run = 0; run < numRuns; run++) {
            std::cout << "  Run " << run + 1 << " of " << numRuns;
            std::cout.flush();
            
            // Set random seed for reproducibility
            std::srand(configIdx * 100 + run);
            
            // Initialize GP
            GPStruct* gp = new GPStruct(
                config.populationSize, 
                dataset->data, 
                config.maxGenerations,
                config.maxDepth, 
                applicationRates, 
                config.tournamentSize, 
                dataset->columnTypes, 
                run
            );

            // Set structured GP parameters if applicable
            if (useStructuredGP) {
                gp->setParameters(config.globalThreshold, config.localThreshold, config.cutoffDepth);
            }
            
            // Train
            auto start = std::chrono::high_resolution_clock::now();
            gp->cachePopulation(run);
            gp->train(run, useStructuredGP);
            auto end = std::chrono::high_resolution_clock::now();
            
            // Test
            config.fitnesses[run] = gp->test(run);
            
            std::chrono::duration<double> elapsed = end - start;
            std::cout << " - Fitness: " << config.fitnesses[run] 
                      << " (Time: " << elapsed.count() << "s)" << std::endl;
            
            delete gp;
        }
        
        // Calculate average fitness and standard deviation
        config.avgFitness = std::accumulate(config.fitnesses.begin(), config.fitnesses.end(), 0.0) / numRuns;
        config.stdDevFitness = calculateStdDev(config.fitnesses, config.avgFitness);
        config.score = calculateScore(config.avgFitness, config.stdDevFitness);
        
        std::cout << "Results for configuration " << configIdx + 1 << ":" << std::endl;
        std::cout << "  Average Fitness: " << config.avgFitness << std::endl;
        std::cout << "  StdDev Fitness: " << config.stdDevFitness << std::endl;
        std::cout << "  Score: " << config.score << std::endl;
        std::cout << "-------------------------" << std::endl;
        
        configurations.push_back(config);
    }
    
    // Sort configurations by score (higher is better)
    std::sort(configurations.begin(), configurations.end(), 
              [](const Configuration& a, const Configuration& b) {
                  return a.score > b.score;
              });
    
    // Print top configurations
    std::cout << "Top 5 configurations:" << std::endl;
    for (int i = 0; i < std::min(5, static_cast<int>(configurations.size())); i++) {
        std::cout << "Rank " << i + 1 << ":" << std::endl;
        printConfiguration(configurations[i]);
        std::cout << "-------------------------" << std::endl;
    }
    
    // Save configurations to file
    std::string filename = useStructuredGP ? "structureGP_configs.csv" : "normalGP_configs.csv";
    saveConfigurationsToCSV(configurations, filename);
    std::cout << "Configuration results saved to " << filename << std::endl;
    
    // Free resources
    delete dataset;
}

// Run the best configuration with more repetitions for final evaluation
void runBestConfiguration(bool useStructuredGP = true) {
    std::cout << "Running best configuration for " 
              << (useStructuredGP ? "Structure-based GP" : "Normal GP") << std::endl;
    
    // Load dataset
    Dataset* dataset = fetchDataset("preprocessing/hepatitis_cleaned.tsv");
    if (!dataset) {
        std::cerr << "Failed to load dataset" << std::endl;
        return;
    }
    
    // Best configuration parameters
    // NOTE: Replace these with your actual best parameters found during tuning
    Configuration bestConfig;
    
    if (useStructuredGP) {
        // Best parameters for structured GP (example - replace with actual best)
        bestConfig.maxGenerations = 150;
        bestConfig.populationSize = 150;
        bestConfig.maxDepth = 6;
        bestConfig.crossoverRate = 0.8;
        bestConfig.mutationRate = 0.15;
        bestConfig.tournamentSize = 5;
    } else {
        // Best parameters for normal GP (example - replace with actual best)
        bestConfig.maxGenerations = 100;
        bestConfig.populationSize = 120;
        bestConfig.maxDepth = 5;
        bestConfig.crossoverRate = 0.7;
        bestConfig.mutationRate = 0.2;
        bestConfig.tournamentSize = 4;
    }
    
    std::vector<double> applicationRates = {bestConfig.crossoverRate, bestConfig.mutationRate};
    
    // Number of runs for final evaluation
    const int numRuns = 10;
    
    std::cout << "Final evaluation with:" << std::endl;
    std::cout << "Max generations: " << bestConfig.maxGenerations << std::endl;
    std::cout << "Population Size: " << bestConfig.populationSize << std::endl;
    std::cout << "Max Depth: " << bestConfig.maxDepth << std::endl;
    std::cout << "Crossover Rate: " << bestConfig.crossoverRate << std::endl;
    std::cout << "Mutation Rate: " << bestConfig.mutationRate << std::endl;
    std::cout << "Tournament Size: " << bestConfig.tournamentSize << std::endl;
    std::cout << "Number of runs: " << numRuns << std::endl;
    
    // Run multiple times
    std::vector<double> fitnesses(numRuns);
    std::vector<double> durations(numRuns);
    
    for (int run = 0; run < numRuns; run++) {
        std::cout << "Run " << run + 1 << " of " << numRuns << std::endl;
        
        // Set random seed for reproducibility
        std::srand(run * 1000);
        
        // Initialize GP
        GPStruct* gp = new GPStruct(
            bestConfig.populationSize, 
            dataset->data, 
            bestConfig.maxGenerations, 
            bestConfig.maxDepth, 
            applicationRates, 
            bestConfig.tournamentSize, 
            dataset->columnTypes, 
            run
        );
        
        // Train
        auto start = std::chrono::high_resolution_clock::now();
        gp->cachePopulation(run);
        gp->train(run, useStructuredGP);
        auto end = std::chrono::high_resolution_clock::now();
        
        // Test
        fitnesses[run] = gp->test(run);
        
        std::chrono::duration<double> elapsed = end - start;
        durations[run] = elapsed.count();
        
        std::cout << "  Fitness: " << fitnesses[run] 
                  << " (Time: " << durations[run] << "s)" << std::endl;
        
        delete gp;
    }
    
    // Calculate statistics
    double avgFitness = std::accumulate(fitnesses.begin(), fitnesses.end(), 0.0) / numRuns;
    double stdDevFitness = calculateStdDev(fitnesses, avgFitness);
    double avgDuration = std::accumulate(durations.begin(), durations.end(), 0.0) / numRuns;
    
    // Find min and max fitness
    double minFitness = *std::min_element(fitnesses.begin(), fitnesses.end());
    double maxFitness = *std::max_element(fitnesses.begin(), fitnesses.end());
    
    // Print results
    std::cout << "Final Results:" << std::endl;
    std::cout << "  Average Fitness: " << avgFitness << std::endl;
    std::cout << "  StdDev Fitness: " << stdDevFitness << std::endl;
    std::cout << "  Min Fitness: " << minFitness << std::endl;
    std::cout << "  Max Fitness: " << maxFitness << std::endl;
    std::cout << "  Average Duration: " << avgDuration << "s" << std::endl;
    
    // Save individual run results to CSV
    std::string filename = useStructuredGP ? "structureGP_final_results.csv" : "normalGP_final_results.csv";
    std::ofstream file(filename);
    if (file.is_open()) {
        file << "Run,Fitness,Duration\n";
        for (int i = 0; i < numRuns; i++) {
            file << i + 1 << "," << fitnesses[i] << "," << durations[i] << "\n";
        }
        file.close();
        std::cout << "Individual run results saved to " << filename << std::endl;
    }
    
    // Free resources
    delete dataset;
}

int main() {
    // Seed the random number generator
    std::srand(static_cast<unsigned int>(std::time(nullptr)));
    
    // Tune hyperparameters for normal GP
    std::cout << "=== Tuning Normal GP ===" << std::endl;
    tuneHyperparameters(false);

    // pause and wait for user input
    std::cout << "Press Enter to continue..." << std::endl;
    std::cin.get();
    
    // Tune hyperparameters for structured GP
    std::cout << "\n=== Tuning Structure-based GP ===" << std::endl;
    tuneHyperparameters(true);
    
    // // Run final evaluation with best configuration
    // std::cout << "\n=== Final Evaluation: Normal GP ===" << std::endl;
    // runBestConfiguration(false);
    
    // std::cout << "\n=== Final Evaluation: Structure-based GP ===" << std::endl;
    // runBestConfiguration(true);
    
    return 0;
}